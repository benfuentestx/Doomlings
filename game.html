<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Doomlings - Game</title>
  <link rel="stylesheet" href="css/styles.css">
  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
</head>
<body>
  <div class="game-container" id="game-container">
    <!-- Game Header -->
    <div class="game-header">
      <div class="age-display">
        <div class="age-card" id="age-card">
          <div class="age-name">Loading...</div>
          <div class="age-effect"></div>
        </div>
        <div class="catastrophe-counter">
          <div class="catastrophe-dot" id="cat-1"></div>
          <div class="catastrophe-dot" id="cat-2"></div>
          <div class="catastrophe-dot" id="cat-3"></div>
        </div>
      </div>
      <div id="turn-indicator"></div>
      <div class="gene-pool-display">
        <span class="gene-pool-label">GP:</span>
        <span class="gene-pool-value" id="gene-pool-value">5</span>
        <span class="gene-pool-value" id="gene-count-value" style="margin-left:4px">+0</span>
      </div>
      <div class="game-stats">
        <span>Round: <strong id="round-num">1</strong></span>
        <span>Deck: <strong id="deck-size">0</strong></span>
        <span>Discard: <strong id="discard-size">0</strong></span>
      </div>
    </div>

    <!-- Left Panel - Opponents -->
    <div class="opponents-panel" id="opponents-left"></div>

    <!-- Main Play Area -->
    <div class="play-area">
      <!-- Action Area -->
      <div class="action-area" id="action-area">
        <div class="action-message" id="action-message">Waiting for game to start...</div>
        <div class="action-options" id="action-options"></div>
      </div>

      <!-- My Trait Pile -->
      <div class="my-traits">
        <h3>
          <span>Your Trait Pile</span>
          <span class="my-score" id="my-score">0 pts</span>
        </h3>
        <div class="trait-pile" id="my-trait-pile"></div>
      </div>

      <!-- Action Log -->
      <div class="log-panel">
        <h4>Game Log</h4>
        <div id="action-log"></div>
      </div>
    </div>

    <!-- Right Panel - More Opponents -->
    <div class="opponents-panel" id="opponents-right"></div>

    <!-- My Hand -->
    <div class="my-hand-area">
      <div class="hand-header">
        <h3>Your Hand (<span id="hand-count">0</span>)</h3>
        <button id="hand-view-toggle" class="hand-view-toggle" title="Toggle card view">
          <span class="toggle-icon">üìù</span>
        </button>
        <span id="play-instruction"></span>
      </div>
      <div class="my-hand" id="my-hand"></div>
      <!-- Mobile Action Bar (inside hand area for mobile) -->
      <div class="mobile-action-bar" id="mobile-action-bar">
        <span class="action-msg">Loading...</span>
      </div>
    </div>
  </div>

  <!-- Modal for card selection -->
  <div class="modal-overlay" id="modal" style="display: none;">
    <div class="modal-content">
      <h2 id="modal-title">Select</h2>
      <div class="modal-cards" id="modal-cards"></div>
      <div class="modal-actions" id="modal-actions">
        <button id="modal-confirm" style="display: none;">Confirm</button>
        <button id="modal-skip" class="secondary" style="display: none;">Skip</button>
        <button id="modal-close" class="secondary">Close</button>
      </div>
    </div>
  </div>

  <!-- Game Over Overlay -->
  <div class="game-over-overlay" id="game-over" style="display: none;">
    <div class="game-over-content">
      <h1>Game Over!</h1>
      <div class="final-scores" id="final-scores"></div>
      <button onclick="location.href='index.html'">Back to Home</button>
    </div>
  </div>

  <!-- Age Announcement Modal -->
  <div class="age-announce-overlay" id="age-announce" style="display: none;">
    <div class="age-announce-card" id="age-announce-card">
      <div class="age-announce-label">NEW AGE</div>
      <h2 class="age-announce-name" id="age-announce-name">Age Name</h2>
      <div class="age-announce-effect" id="age-announce-effect">Effect description</div>
      <button class="age-announce-btn" onclick="window.dismissAgeAnnounce()">Continue</button>
    </div>
  </div>

  <!-- Card Detail View -->
  <div class="card-detail-overlay" id="card-detail" style="display: none;">
    <div class="card-detail-backdrop"></div>
    <div class="card-detail-container">
      <button class="card-detail-nav card-detail-prev" id="card-detail-prev">‚Äπ</button>
      <div class="card-detail-card" id="card-detail-content">
        <!-- Card content injected here -->
      </div>
      <button class="card-detail-nav card-detail-next" id="card-detail-next">‚Ä∫</button>
    </div>
    <div class="card-detail-actions">
      <button class="card-detail-play" id="card-detail-play" style="display: none;">Play Card</button>
      <button class="card-detail-close" id="card-detail-close">Close</button>
    </div>
    <div class="card-detail-counter" id="card-detail-counter">1 / 5</div>
  </div>

  <!-- Loading -->
  <div id="loading" class="message-overlay">
    <div class="spinner"></div>
    <p>Loading game...</p>
  </div>

  <script type="module">
    import { peerManager } from './js/peer-manager.js';
    import { reconnectManager } from './js/reconnect-manager.js';

    // Get player data - try sessionStorage first, then localStorage (for reconnection)
    let playerData = JSON.parse(sessionStorage.getItem('playerData'));
    if (!playerData) {
      // Try to load from localStorage (reconnection after refresh)
      const savedSession = reconnectManager.loadSession();
      if (savedSession) {
        playerData = savedSession;
        // Restore to sessionStorage for this session
        sessionStorage.setItem('playerData', JSON.stringify(playerData));
        sessionStorage.setItem('isHost', playerData.isHost ? 'true' : 'false');
      }
    }
    let gameState = null;
    let selectedCards = [];
    let pendingAction = null;

    // DOM Elements
    const loadingOverlay = document.getElementById('loading');
    const ageCard = document.getElementById('age-card');
    const turnIndicator = document.getElementById('turn-indicator');
    const roundNum = document.getElementById('round-num');
    const deckSize = document.getElementById('deck-size');
    const discardSize = document.getElementById('discard-size');
    const genePoolValue = document.getElementById('gene-pool-value');
    const geneCountValue = document.getElementById('gene-count-value');
    let stabilizeDiscards = []; // Selected cards for stabilization discard
    const actionMessage = document.getElementById('action-message');
    const actionOptions = document.getElementById('action-options');
    const myTraitPile = document.getElementById('my-trait-pile');
    const myHand = document.getElementById('my-hand');
    const myScore = document.getElementById('my-score');
    const handCount = document.getElementById('hand-count');
    const playInstruction = document.getElementById('play-instruction');
    const handViewToggle = document.getElementById('hand-view-toggle');
    const actionLog = document.getElementById('action-log');
    const opponentsLeft = document.getElementById('opponents-left');
    const opponentsRight = document.getElementById('opponents-right');
    const modal = document.getElementById('modal');
    const modalTitle = document.getElementById('modal-title');
    const modalCards = document.getElementById('modal-cards');
    const modalConfirm = document.getElementById('modal-confirm');
    const modalSkip = document.getElementById('modal-skip');
    const modalClose = document.getElementById('modal-close');
    const gameOverOverlay = document.getElementById('game-over');
    const finalScores = document.getElementById('final-scores');
    const mobileActionBar = document.getElementById('mobile-action-bar');
    const ageAnnounceOverlay = document.getElementById('age-announce');
    const ageAnnounceCard = document.getElementById('age-announce-card');
    const ageAnnounceName = document.getElementById('age-announce-name');
    const ageAnnounceEffect = document.getElementById('age-announce-effect');
    const cardDetailOverlay = document.getElementById('card-detail');
    const cardDetailContent = document.getElementById('card-detail-content');
    const cardDetailClose = document.getElementById('card-detail-close');
    const cardDetailPrev = document.getElementById('card-detail-prev');
    const cardDetailNext = document.getElementById('card-detail-next');
    const cardDetailPlay = document.getElementById('card-detail-play');
    const cardDetailCounter = document.getElementById('card-detail-counter');

    let lastShownAgeName = null; // Track which age we've shown
    let ageHistory = [];           // Track all ages played in order

    // Card detail navigation state
    let cardDetailCards = [];      // Array of cards being viewed
    let cardDetailIndex = 0;       // Current index in array
    let cardDetailSource = null;   // 'hand', 'traitPile', or 'opponent'
    let cardDetailPlayable = false; // Whether current card can be played

    // Drag-and-drop state
    let draggedCardIndex = null;
    let isDragging = false;

    // Hand view mode: 'text' or 'image'
    let handViewMode = 'image';

    // Image name mapping for cards that don't have direct name matches
    // Maps trait name (without suffixes) to actual image file name
    const cardImageMapping = {
      // Cards with multiple variants that use the same image
      'BRAVE': 'BRAVE',              // Brave (1), Brave (2) -> BRAVE.png
      'CAMOUFLAGE': 'CAMOUFLAGE',    // Camouflage (1), Camouflage (2) -> CAMOUFLAGE.png
      'FORTUNATE': 'FORTUNATE',      // Fortunate (~), Fortunate (1) -> FORTUNATE.png
      'BOREDOM': 'BOREDOM',          // Boredom (1), Boredom (~) -> BOREDOM.png
      'SAUDADE': 'SAUDADE',          // Saudade (1) -> SAUDADE.png
      'AUTOMIMICRY': 'AUTOMIMICRY',  // Automimicry (0), Automimicry (-1) -> AUTOMIMICRY.png
      // Cards without images - use placeholders
      'JUNK DNA': 'MITOCHONDRION',   // Junk DNA (1), (2) - use MITOCHONDRION as placeholder
    };

    // Card effect descriptions (for card detail view)
    const cardEffectDescriptions = {
      // Action cards
      'Automimicry (0)': 'Copy the effect of any trait in an opponent\'s trait pile.',
      'Cold Blood': 'Draw 1 card.',
      'Costly Signaling': 'Steal a random card from an opponent\'s hand.',
      'Flight': 'Return one of your traits to your hand.',
      'Iridescent Scales': 'Swap 1 card from your hand with 1 card from an opponent\'s hand.',
      'Painted Shell': 'Look at an opponent\'s hand.',
      'Scutes': 'Your traits cannot be stolen or discarded this round.',
      'Selective Memory': 'Take a card from the discard pile.',
      'Sweat': 'Discard 1 card, then draw 2 cards.',
      'Tentacles': 'Steal a trait from an opponent\'s trait pile.',
      'Photosynthesis': 'Draw 1 card.',
      'Propagation': 'If you have another Green trait, draw 1 card.',
      'Self-Replicating': 'Draw 1 card at the start of each round.',
      'Tiny Little Melons': 'Give a card from your hand to another player.',
      'Trunk': 'Draw 2 cards.',
      'Clever': 'Look at the top 3 cards of the deck.',
      'Directly Register': 'Draw 1 card.',
      'Impatience': 'Draw 2 cards, then discard 1 card.',
      'Inventive': 'Rearrange your traits in any order.',
      'Memory': 'Take a card from the discard pile.',
      'Nosy': 'Look at an opponent\'s hand.',
      'Persuasive': 'Swap one of your traits with an opponent\'s trait.',
      'Poisonous': 'Discard a trait from an opponent\'s trait pile.',
      'Selfish': 'Steal a random card from an opponent\'s hand.',
      'Telekinetic': 'Move a trait from one player to another.',
      'Venomous': 'An opponent discards 2 cards from their hand.',
      'Bad': 'Opponents discard 2 cards from their hand at random.',
      'Brave (2)': 'Draw 1 card.',
      'Hot Temper': 'Discard up to 2 cards, then draw that many +1.',
      'Reckless': 'Discard your hand and draw that many +1.',
      'Territorial': 'Steal a Red trait from an opponent.',
      'Voracious': 'Draw 2 cards.',
      'Boredom (1)': 'Draw 1 card.',
      'Doting': 'Give 2 cards from your hand to another player.',
      'Introspective': 'Draw 1 card.',
      'The Third Eye': 'Look at the next 3 age cards.',
      // Dominant cards
      'Apex Predator': '+4 if you have the most traits in your trait pile.',
      'Camouflage (1)': '+1 for each card in your hand.',
      'Camouflage (2)': '+1 for each card in your hand.',
      'Denial': 'Cannot be removed. +2 for each Dominant in your trait pile.',
      'Echolocation': '+2 for each Blue trait in your trait pile.',
      'Faith': '+3 for each Colorless trait in your trait pile.',
      'Heroic': '+2 for each trait with a negative face value in your trait pile.',
      'Hyper-Intelligence': '+1 for each trait in your trait pile.',
      'Immunity': '+2 for each trait with a negative face value in your trait pile.',
      'Optimistic Nihilism': '+3 for each unique color in your trait pile.',
      'Pack Behavior': '+1 for each pair of same-colored traits in your trait pile.',
      'Sentience': '+1 for each World\'s End card of different colors in your trait pile.',
      'Symbiosis': '+2 for the color you have the least of in your trait pile.',
      'Tiny': '-1 for each trait in your trait pile.',
      'Vampirism': '+2 for each Red trait in your trait pile.',
      'Viral': '-1 to each opponent for each World\'s End of the same color.',
      // Drop cards with effects
      'Altruistic': 'Value is equal to your Gene Pool.',
      'Boredom (~)': 'Value is equal to the number of cards with effects in your hand.',
      'Branches': '+1 for each pair of Green traits in other players\' trait piles.',
      'Brave (1)': '+2 for each Dominant in your hand.',
      'Egg Clusters': '+1 for each Blue trait in your trait pile.',
      'Fortunate (~)': 'Value is equal to the number of cards in your hand.',
      'Fortunate (1)': '+2 if you have the most Green traits.',
      'Gratitude': 'Value is equal to the number of unique colors in your trait pile.',
      'Heat Vision': 'Variable value.',
      'Kidney (r)': 'Value is equal to the number of Kidney traits in your trait pile.',
      'Mindful': '+1 for each Colorless trait in your trait pile.',
      'Overgrowth': '+1 for each Green trait in your trait pile.',
      'Pollination': '+1 for each trait with face value 1 in your trait pile.',
      'Random Fertilization': 'Value is equal to your Gene Pool.',
      'Saudade (1)': '+1 for each unique color in your hand.',
      'Sticky Secretions': '+1 for each Purple trait in your trait pile.',
      'Swarm (g)': 'Value is equal to the number of Swarm traits in all trait piles. (Including this one.)',
      'Bioluminescence': '+1 for each Blue trait in your trait pile.',
      'Warning Coloration': '+1 for each Red trait in your trait pile.',
      'Necrosis': '+1 for each Purple trait in your trait pile.',
      'Mutation': '+1 for each unique color in your trait pile.',
      'Thick Skin': '+1 for each Colorless trait in your trait pile.',
      'Junk DNA (1)': '+1 for each card in your hand.',
      'Junk DNA (2)': '+1 for each card in your hand.',
      'Opposable Thumbs': '+1 for each trait in your trait pile.'
    };

    const isHost = sessionStorage.getItem('isHost') === 'true';

    // Check session
    if (!playerData) {
      window.location.href = 'index.html';
    } else {
      // Set up game state update callback
      peerManager.onGameStateUpdate = (state) => {
        loadingOverlay.style.display = 'none';
        gameState = state;
        renderGame();
      };

      peerManager.onError = (error) => {
        alert(error);
      };

      peerManager.onDisconnected = () => {
        console.log('Disconnected from host, will retry...');
        // Don't immediately redirect - host may be navigating
        setTimeout(() => {
          retryGameConnection();
        }, 1500);
      };

      let retryCount = 0;
      const maxRetries = 3;

      async function retryGameConnection() {
        if (retryCount >= maxRetries) {
          alert('Lost connection to game');
          window.location.href = 'index.html';
          return;
        }
        retryCount++;
        console.log(`Retry attempt ${retryCount}/${maxRetries}`);
        try {
          // Preserve playerId for reconnection
          if (playerData.playerId) {
            peerManager.myPlayerId = playerData.playerId;
          }
          await peerManager.joinGame(playerData.gameId, playerData.playerName);
          retryCount = 0;
        } catch (err) {
          setTimeout(retryGameConnection, 1500);
        }
      }

      // Initialize connection
      initializeGame();
    }

    async function initializeGame() {
      try {
        if (isHost) {
          // Host needs to restore their peer connection and game state
          await peerManager.restoreHost(playerData.gameId, playerData.playerId, playerData.playerName);

          // Verify game state was restored properly
          const state = peerManager.getMyState();
          if (!state || state.round === 0) {
            console.error('Game state not properly restored');
            // Try to get state from sessionStorage directly as backup
            const backup = sessionStorage.getItem('gameStateBackup');
            if (backup) {
              console.log('Attempting direct restore from backup');
            }
          }

          loadingOverlay.style.display = 'none';

          // Initial render
          if (state) {
            gameState = state;
            renderGame();
          }

          // Periodic refresh for host
          setInterval(() => {
            const newState = peerManager.getMyState();
            if (newState) {
              gameState = newState;
              renderGame();
            }
          }, 200);

        } else {
          // Client needs to rejoin the game
          // Restore playerId so we're recognized as the same player
          if (playerData.playerId) {
            peerManager.myPlayerId = playerData.playerId;
          }

          // Use a retry loop since host may still be setting up
          let connected = false;
          for (let attempt = 0; attempt < 5 && !connected; attempt++) {
            try {
              if (attempt > 0) {
                await new Promise(r => setTimeout(r, 1000)); // Wait between attempts
              }
              await peerManager.joinGame(playerData.gameId, playerData.playerName);
              connected = true;
            } catch (err) {
              console.log(`Join attempt ${attempt + 1} failed:`, err);
            }
          }

          if (!connected) {
            throw { error: 'Failed to connect to game after multiple attempts' };
          }

          loadingOverlay.style.display = 'none';
        }
      } catch (err) {
        loadingOverlay.style.display = 'none';
        alert(err.error || 'Failed to connect to game');
        window.location.href = 'index.html';
      }
    }

    // Render the game
    function renderGame() {
      if (!gameState) return;

      // Update catastrophe dots
      for (let i = 1; i <= 3; i++) {
        document.getElementById(`cat-${i}`).classList.toggle('active', i <= gameState.catastropheCount);
      }

      // Update age card
      if (gameState.currentAge) {
        const isCatastrophe = gameState.currentAge.type === 'catastrophe';
        ageCard.className = 'age-card' + (isCatastrophe ? ' catastrophe' : '');

        // Show active rule effect if any
        let ruleEffectHtml = '';
        if (gameState.ageEffect && gameState.currentAge.ruleEffectText) {
          ruleEffectHtml = `<div class="age-rule-effect">${gameState.currentAge.ruleEffectText}</div>`;
        }

        ageCard.innerHTML = `
          <div class="age-name">${gameState.currentAge.name}</div>
          <div class="age-effect">${gameState.currentAge.effect || ''}</div>
          ${ruleEffectHtml}
        `;

        // Show age announcement if this is a new age
        if (gameState.currentAge.name !== lastShownAgeName) {
          showAgeAnnouncement(gameState.currentAge);
          // Add to age history if not already there
          if (!ageHistory.find(age => age.name === gameState.currentAge.name)) {
            ageHistory.push({...gameState.currentAge});
          }
        }
      }

      // Update stats
      roundNum.textContent = gameState.round;
      deckSize.textContent = gameState.deckSize;
      discardSize.textContent = gameState.discardSize;

      // Update gene pool (hand size target) and gene count (from cards)
      genePoolValue.textContent = gameState.myGenePool || 5;
      const geneCount = gameState.myGeneCount || 0;
      geneCountValue.textContent = geneCount >= 0 ? `+${geneCount}` : geneCount;
      geneCountValue.className = 'gene-pool-value' + (geneCount < 0 ? ' negative' : '');

      // Update turn indicator
      if (gameState.state === 'finished') {
        turnIndicator.innerHTML = '<span class="turn-indicator" style="background: var(--success);">Game Over</span>';
      } else if (gameState.isMyTurn) {
        turnIndicator.innerHTML = '<span class="turn-indicator">Your Turn!</span>';
      } else {
        const currentPlayer = gameState.players.find(p => p.isCurrentPlayer);
        turnIndicator.innerHTML = `<span style="color: var(--text-secondary);">${currentPlayer?.name || 'Unknown'}'s turn</span>`;
      }

      // Update my score
      myScore.textContent = `${gameState.myScore} pts`;

      // Render my trait pile
      renderTraitPile(myTraitPile, gameState.myTraitPile);

      // Render my hand
      renderHand();

      // Render opponents
      renderOpponents();

      // Update action area
      updateActionArea();

      // Update log
      renderLog();

      // Check for game over
      if (gameState.state === 'finished') {
        showGameOver();
      }

      // Handle pending action
      if (gameState.pendingAction) {
        handlePendingAction(gameState.pendingAction);
      }
    }

    // Render a trait pile
    function renderTraitPile(container, cards) {
      container.innerHTML = '';
      cards.forEach((card, index) => {
        const cardEl = createCardElement(card, false, index);
        // Tap to show card detail - pass full array for navigation
        cardEl.addEventListener('click', () => showCardDetail(card, cards, index, 'traitPile'));
        container.appendChild(cardEl);
      });
    }

    // Render hand
    function renderHand() {
      myHand.innerHTML = '';
      handCount.textContent = gameState.myHand.length;

      const canPlay = gameState.isMyTurn && gameState.turnPhase === 'play' && !gameState.pendingAction;
      const isStabilizing = gameState.isMyTurn && gameState.turnPhase === 'stabilize';
      const needsDiscard = gameState.needsDiscard || 0;

      // Set up drop zone for trait pile when can play
      if (canPlay) {
        myTraitPile.classList.add('drop-target');
        myTraitPile.ondragover = (e) => {
          e.preventDefault();
          myTraitPile.classList.add('drop-hover');
        };
        myTraitPile.ondragleave = () => {
          myTraitPile.classList.remove('drop-hover');
        };
        myTraitPile.ondrop = (e) => {
          e.preventDefault();
          myTraitPile.classList.remove('drop-hover');
          if (draggedCardIndex !== null) {
            playCard(draggedCardIndex);
            draggedCardIndex = null;
          }
        };
      } else {
        myTraitPile.classList.remove('drop-target');
        myTraitPile.ondragover = null;
        myTraitPile.ondragleave = null;
        myTraitPile.ondrop = null;
      }

      gameState.myHand.forEach((card, index) => {
        const cardEl = createCardElement(card, canPlay || isStabilizing, index);

        if (canPlay) {
          // Desktop drag-and-drop
          cardEl.draggable = true;
          cardEl.ondragstart = (e) => {
            draggedCardIndex = index;
            isDragging = true;
            cardEl.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
          };
          cardEl.ondragend = () => {
            isDragging = false;
            cardEl.classList.remove('dragging');
            myTraitPile.classList.remove('drop-hover');
          };

          // Mobile touch drag
          let touchStartX = 0;
          let touchStartY = 0;
          let touchMoved = false;

          cardEl.addEventListener('touchstart', (e) => {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
            touchMoved = false;
            draggedCardIndex = index;
          }, { passive: true });

          cardEl.addEventListener('touchmove', (e) => {
            const dx = Math.abs(e.touches[0].clientX - touchStartX);
            const dy = Math.abs(e.touches[0].clientY - touchStartY);
            if (dx > 20 || dy > 20) {
              touchMoved = true;
              isDragging = true;
              cardEl.classList.add('dragging');

              // Check if over trait pile
              const touch = e.touches[0];
              const traitRect = myTraitPile.getBoundingClientRect();
              if (touch.clientX >= traitRect.left && touch.clientX <= traitRect.right &&
                  touch.clientY >= traitRect.top && touch.clientY <= traitRect.bottom) {
                myTraitPile.classList.add('drop-hover');
              } else {
                myTraitPile.classList.remove('drop-hover');
              }
            }
          }, { passive: true });

          cardEl.addEventListener('touchend', (e) => {
            cardEl.classList.remove('dragging');
            myTraitPile.classList.remove('drop-hover');

            if (!touchMoved) {
              // Tap - show card detail with hand array for navigation
              showCardDetail(card, gameState.myHand, index, 'hand');
            } else if (isDragging && draggedCardIndex !== null) {
              // Check if dropped on trait pile
              const touch = e.changedTouches[0];
              const traitRect = myTraitPile.getBoundingClientRect();
              if (touch.clientX >= traitRect.left && touch.clientX <= traitRect.right &&
                  touch.clientY >= traitRect.top && touch.clientY <= traitRect.bottom) {
                playCard(draggedCardIndex);
              }
            }

            isDragging = false;
            draggedCardIndex = null;
            e.preventDefault();
          });
        } else if (isStabilizing && needsDiscard > 0) {
          // In stabilize mode - can select cards to discard
          cardEl.addEventListener('click', () => toggleStabilizeDiscard(index, cardEl, needsDiscard));
          if (stabilizeDiscards.includes(index)) {
            cardEl.classList.add('selected');
          }
        } else {
          // Not playable - just show detail on tap with hand array for navigation
          cardEl.addEventListener('click', () => showCardDetail(card, gameState.myHand, index, 'hand'));
        }

        myHand.appendChild(cardEl);
      });

      if (canPlay) {
        playInstruction.textContent = 'Drag card to trait pile to play';
      } else if (isStabilizing && needsDiscard > 0) {
        playInstruction.textContent = `Select ${needsDiscard} card(s) to discard, then click Stabilize`;
      } else if (isStabilizing) {
        playInstruction.textContent = gameState.willDraw > 0 ? `You will draw ${gameState.willDraw} card(s)` : '';
      } else {
        playInstruction.textContent = '';
      }
    }

    // Toggle card selection for stabilization discard
    function toggleStabilizeDiscard(index, cardEl, maxDiscards) {
      const idx = stabilizeDiscards.indexOf(index);
      if (idx === -1) {
        if (stabilizeDiscards.length < maxDiscards) {
          stabilizeDiscards.push(index);
          cardEl.classList.add('selected');
        }
      } else {
        stabilizeDiscards.splice(idx, 1);
        cardEl.classList.remove('selected');
      }
      // Update action area to reflect current selection count
      updateActionArea();
    }

    // Create a card element
    function createCardElement(card, playable = false, index = 0) {
      const div = document.createElement('div');
      const colorClass = getColorClass(card.color);

      if (handViewMode === 'image') {
        // Image mode - show actual card image
        div.className = `hand-card-image ${colorClass}${playable ? ' playable' : ''}`;
        div.dataset.index = index;

        // Get card image path (same logic as card detail view)
        let displayName = (card.name || '').replace(/\s*\([^)]*\)\s*$/, '').toUpperCase();
        const imageName = cardImageMapping[displayName] || displayName;
        const imageUrl = `images/cards/${imageName}.png`;

        div.innerHTML = `
          <img src="${imageUrl}" alt="${card.name}"
               onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
          <div class="card-image-fallback" style="display: none;">
            <div class="fallback-name">${card.name}</div>
          </div>
        `;
      } else {
        // Text mode - show simplified card representation
        div.className = `card ${colorClass}${playable ? ' playable' : ''}`;
        div.dataset.index = index;

        let typeText = '';
        if (card.isDominant) typeText = 'DOMINANT';
        else if (card.actions && card.actions.length > 0) typeText = 'ACTION';
        else if (card.bonusPoints) typeText = 'DROP';
        else if (card.effects && card.effects.some(e => e.name === 'modify_gene_pool')) typeText = 'GENE POOL';
        else if (card.worldsEnd) typeText = "WORLD'S END";
        else typeText = 'TRAIT';

        let effectText = getCardEffectText(card);

        div.innerHTML = `
          <div class="card-color" style="background: ${getColorValue(card.color)}"></div>
          <div class="card-face">${formatFace(card.faceValue)}</div>
          <div class="card-name">${card.name}</div>
          <div class="card-effect">${effectText}</div>
          <div class="card-type">${typeText}</div>
        `;
      }

      return div;
    }

    function getColorClass(color) {
      if (!color) return 'colorless';
      if (color.includes('_')) return 'multi';
      return color.toLowerCase();
    }

    function getColorValue(color) {
      const colors = {
        'Red': '#e74c3c', 'Blue': '#3498db', 'Green': '#27ae60',
        'Purple': '#9b59b6', 'Colorless': '#95a5a6'
      };
      if (color && color.includes('_')) {
        return 'linear-gradient(135deg, #e74c3c, #3498db, #27ae60, #9b59b6)';
      }
      return colors[color] || colors['Colorless'];
    }

    function formatFace(face) {
      if (face === null || face === undefined) return '?';
      if (face === 'variable') return '?';
      if (face === 'copy_1st_dominant') return '=';
      return face;
    }

    function getCardEffectText(card) {
      // Check for actionDescription (from new format)
      if (card.actionDescription) return card.actionDescription;

      // Check for bonus points
      if (card.bonusPoints) {
        return card.bonusDescription || 'Bonus points';
      }

      // Check for actions
      if (card.actions && card.actions.length > 0) {
        return card.actionDescription || 'Action effect';
      }

      // Check for dominant
      if (card.isDominant) {
        return card.requirementDescription || 'Dominant';
      }

      // Check for gene pool effects
      if (card.effects) {
        for (const effect of card.effects) {
          if (effect.name === 'modify_gene_pool') {
            const val = effect.params.value || 0;
            return `Genes: ${val >= 0 ? '+' : ''}${val}`;
          }
        }
      }

      // Check for world's end
      if (card.worldsEnd && card.worldsEndDescription) {
        return card.worldsEndDescription;
      }

      return '';
    }

    function formatDropEffect(effect) {
      if (!effect) return '';
      const parts = effect.split(' ');
      if (parts.length < 3) return effect;
      const value = parts[0];
      const condition = parts[2] || '';
      const conditionMap = {
        'n_hand': 'per card in hand', 'n_traits': 'per trait',
        'n_blue': 'per Blue', 'n_green': 'per Green',
        'n_purple': 'per Purple', 'n_colorless': 'per Colorless',
        'n_colors': 'per unique color', 'if_most_traits': 'if most traits'
      };
      const text = conditionMap[condition] || condition.replace(/_/g, ' ');
      if (value === 'n') return `Variable: ${text}`;
      return `${value > 0 ? '+' : ''}${value} ${text}`;
    }

    // Render opponents
    function renderOpponents() {
      const opponents = gameState.players.filter(p => p.id !== playerData.playerId);
      opponentsLeft.innerHTML = '';
      opponentsRight.innerHTML = '';

      opponents.forEach((opp, i) => {
        const container = i % 2 === 0 ? opponentsLeft : opponentsRight;
        const div = document.createElement('div');
        div.className = `opponent-card${opp.isCurrentPlayer ? ' current-turn' : ''}`;

        div.innerHTML = `
          <div class="opponent-header">
            <span class="opponent-name">${opp.name}</span>
            <span class="opponent-score">${opp.score}</span>
          </div>
          <div class="opponent-info">
            Hand: ${opp.handSize} | Traits: ${opp.traitPile.length}
            ${opp.hasPlayedThisRound ? ' | Played' : ''}
          </div>
          <div class="opponent-traits">
            ${opp.traitPile.map(t => `
              <div class="mini-trait ${getColorClass(t.color)}" title="${t.name} (${t.faceValue})">
                ${formatFace(t.faceValue)}
              </div>
            `).join('')}
          </div>
        `;

        container.appendChild(div);
      });
    }

    // Update action area (both desktop and mobile)
    function updateActionArea() {
      actionOptions.innerHTML = '';
      mobileActionBar.innerHTML = '';

      if (gameState.state === 'finished') {
        actionMessage.textContent = 'Game Over!';
        mobileActionBar.innerHTML = '<span class="action-msg">Game Over!</span>';
        return;
      }

      if (gameState.pendingAction) {
        actionMessage.textContent = gameState.pendingAction.message || 'Action required';
        mobileActionBar.innerHTML = `<span class="action-msg">${gameState.pendingAction.message || 'Action required'}</span>`;
        return;
      }

      if (gameState.isMyTurn) {
        if (gameState.turnPhase === 'stabilize') {
          // Stabilization phase
          const needsDiscard = gameState.needsDiscard || 0;
          const willDraw = gameState.willDraw || 0;

          if (needsDiscard > 0) {
            actionMessage.textContent = `Stabilize: Select ${needsDiscard} card(s) to discard`;

            // Desktop button
            const stabilizeBtn = document.createElement('button');
            stabilizeBtn.textContent = `Discard ${stabilizeDiscards.length}/${needsDiscard} & Stabilize`;
            stabilizeBtn.disabled = stabilizeDiscards.length !== needsDiscard;
            stabilizeBtn.onclick = () => {
              if (stabilizeDiscards.length === needsDiscard) {
                peerManager.stabilize(stabilizeDiscards);
                stabilizeDiscards = [];
              }
            };
            actionOptions.appendChild(stabilizeBtn);

            // Mobile bar
            mobileActionBar.innerHTML = `
              <span class="action-msg">Select ${needsDiscard - stabilizeDiscards.length} more</span>
              <button ${stabilizeDiscards.length !== needsDiscard ? 'disabled' : ''}
                      onclick="window.doStabilize()">Stabilize</button>
            `;
          } else if (willDraw > 0) {
            actionMessage.textContent = `Stabilize: You will draw ${willDraw} card(s)`;

            const stabilizeBtn = document.createElement('button');
            stabilizeBtn.textContent = `Draw ${willDraw} & Stabilize`;
            stabilizeBtn.onclick = () => {
              peerManager.stabilize([]);
              stabilizeDiscards = [];
            };
            actionOptions.appendChild(stabilizeBtn);

            // Mobile bar
            mobileActionBar.innerHTML = `
              <span class="action-msg">Draw ${willDraw} cards</span>
              <button onclick="window.doStabilize()">Stabilize</button>
            `;
          } else {
            actionMessage.textContent = 'Hand size matches Gene Pool';

            const stabilizeBtn = document.createElement('button');
            stabilizeBtn.textContent = 'Continue';
            stabilizeBtn.onclick = () => {
              peerManager.stabilize([]);
              stabilizeDiscards = [];
            };
            actionOptions.appendChild(stabilizeBtn);

            // Mobile bar
            mobileActionBar.innerHTML = `
              <span class="action-msg">Hand OK</span>
              <button onclick="window.doStabilize()">Continue</button>
            `;
          }
        } else if (gameState.turnPhase === 'play') {
          // Play phase
          if (!gameState.canPlayAny) {
            // Can't play any cards - must skip turn
            actionMessage.textContent = "You can't play any cards this turn";

            const skipBtn = document.createElement('button');
            skipBtn.textContent = 'Draw 3 & Skip Turn';
            skipBtn.onclick = () => peerManager.skipTurn();
            actionOptions.appendChild(skipBtn);

            // Mobile bar
            mobileActionBar.innerHTML = `
              <span class="action-msg">Can't play</span>
              <button onclick="window.doSkipTurn()">Skip (+3 cards)</button>
            `;
          } else {
            actionMessage.textContent = 'Play a trait from your hand';

            // Optional discard all and draw 3
            const discardBtn = document.createElement('button');
            discardBtn.className = 'secondary';
            discardBtn.textContent = 'Discard All & Draw 3';
            discardBtn.onclick = () => {
              if (confirm('Discard your entire hand and draw 3 new cards?')) {
                peerManager.discardAndDraw();
              }
            };
            actionOptions.appendChild(discardBtn);

            // Mobile bar - show drag to play message
            mobileActionBar.innerHTML = `
              <span class="action-msg">Drag card to trait pile</span>
              <button class="secondary" onclick="window.doDiscardAll()">Redraw</button>
            `;
          }
        } else {
          actionMessage.textContent = 'Waiting...';
          mobileActionBar.innerHTML = '<span class="action-msg">Waiting...</span>';
        }
      } else {
        const currentPlayer = gameState.players.find(p => p.isCurrentPlayer);
        const name = currentPlayer?.name || 'opponent';
        actionMessage.textContent = `Waiting for ${name}...`;
        mobileActionBar.innerHTML = `<span class="action-msg">${name}'s turn</span>`;
      }
    }

    // Global functions for mobile button handlers
    window.doStabilize = function() {
      const needsDiscard = gameState.needsDiscard || 0;
      if (needsDiscard > 0 && stabilizeDiscards.length !== needsDiscard) return;
      peerManager.stabilize(stabilizeDiscards);
      stabilizeDiscards = [];
    };

    window.doSkipTurn = function() {
      peerManager.skipTurn();
    };

    window.doDiscardAll = function() {
      if (confirm('Discard your entire hand and draw 3 new cards?')) {
        peerManager.discardAndDraw();
      }
    };

    // Show age announcement modal
    function showAgeAnnouncement(age) {
      if (!age || !age.name) return;

      const isCatastrophe = age.type === 'catastrophe';

      // Update modal content
      ageAnnounceCard.className = 'age-announce-card' + (isCatastrophe ? ' catastrophe' : '');
      document.querySelector('.age-announce-label').textContent = isCatastrophe ? 'CATASTROPHE' : 'NEW AGE';
      ageAnnounceName.textContent = age.name;

      // Build effect description
      let effectText = age.effect || '';
      if (age.ruleEffectText) {
        effectText += (effectText ? '<br><br>' : '') + age.ruleEffectText;
      }
      if (age.genePoolEffect) {
        const gp = age.genePoolEffect;
        effectText += (effectText ? '<br><br>' : '') + `Gene Pool: ${gp > 0 ? '+' : ''}${gp}`;
      }
      if (!effectText) {
        effectText = isCatastrophe ? 'A catastrophic event affects all players!' : 'A new age begins...';
      }

      ageAnnounceEffect.innerHTML = effectText;
      ageAnnounceOverlay.style.display = 'flex';
      lastShownAgeName = age.name;
    }

    window.dismissAgeAnnounce = function() {
      ageAnnounceOverlay.style.display = 'none';
    };

    // Show card detail view with navigation support
    function showCardDetail(card, cardsArray = [card], index = 0, source = 'single') {
      cardDetailCards = cardsArray;
      cardDetailIndex = index;
      cardDetailSource = source;

      renderCardDetail();
      cardDetailOverlay.style.display = 'flex';
    }

    // Render the current card in detail view
    function renderCardDetail() {
      const card = cardDetailCards[cardDetailIndex];
      if (!card) return;

      // Check if this is an age card
      const isAge = card.type === 'age' || card.type === 'catastrophe';

      let typeText = '';
      let showStar = false;
      if (isAge) {
        typeText = card.type === 'catastrophe' ? 'CATASTROPHE' : 'AGE';
      } else if (card.isDominant) {
        typeText = 'DOMINANT';
        showStar = true;
      } else if (card.actions && card.actions.length > 0) {
        typeText = 'ACTION';
      } else if (card.bonusPoints) {
        typeText = 'DROP';
      } else if (card.effects && card.effects.some(e => e.name === 'modify_gene_pool')) {
        typeText = 'GENE POOL';
      } else if (card.worldsEnd) {
        typeText = "WORLD'S END";
      } else {
        typeText = 'TRAIT';
      }

      // For detail view, prioritize description fields from new format
      let effectText = '';

      // For ages, use description or effect field
      if (isAge) {
        effectText = card.description || card.effect || '';
      } else if (card.actionDescription) {
        effectText = card.actionDescription;
      } else if (card.bonusDescription) {
        effectText = card.bonusDescription;
      } else if (card.requirementDescription) {
        effectText = card.requirementDescription;
      } else if (card.worldsEndDescription) {
        effectText = card.worldsEndDescription;
      }

      // Look up effect description from our comprehensive mapping
      if (!effectText && cardEffectDescriptions[card.name]) {
        effectText = cardEffectDescriptions[card.name];
      }

      // For gene pool cards, show the gene pool effect
      if (!effectText && card.effects) {
        for (const effect of card.effects) {
          if (effect.name === 'modify_gene_pool') {
            const val = effect.params.value || 0;
            effectText = `Gene Pool: ${val >= 0 ? '+' : ''}${val}`;
            break;
          }
        }
      }

      // For ages, use special color class; for traits use normal color
      const colorClass = isAge
        ? (card.type === 'catastrophe' ? 'catastrophe-card' : 'age-card-detail')
        : getColorClass(card.color);

      // Clean up card name - remove suffixes like (g), (1), (~), (r), etc.
      let displayName = (card.name || '').replace(/\s*\([^)]*\)\s*$/, '').toUpperCase();

      // Use card name directly - all image files are UPPERCASE
      const imageName = cardImageMapping[displayName] || displayName;
      const imageUrl = `images/cards/${imageName}.png`;

      cardDetailContent.className = 'card-detail-card';
      cardDetailContent.innerHTML = `
        <div class="card-detail-image-container">
          <img class="card-detail-image" src="${imageUrl}" alt="${displayName}"
               onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
          <div class="card-detail-fallback ${colorClass}" style="display: none;">
            <div class="card-detail-type-badge">${typeText}</div>
            ${showStar ? '<div class="card-detail-star">‚òÖ</div>' : ''}
            <div class="card-detail-name-banner">
              <span class="card-detail-name">${displayName}</span>
            </div>
            <div class="card-detail-artwork">
              <span class="artwork-placeholder">Image Not Found</span>
            </div>
            <div class="card-detail-effect">${effectText || 'No special effect'}</div>
            ${!isAge ? `<div class="card-detail-face">${formatFace(card.faceValue)}</div>` : ''}
          </div>
        </div>
      `;

      // Update navigation visibility
      cardDetailPrev.style.display = cardDetailCards.length > 1 ? 'flex' : 'none';
      cardDetailNext.style.display = cardDetailCards.length > 1 ? 'flex' : 'none';

      // Update counter
      cardDetailCounter.textContent = `${cardDetailIndex + 1} / ${cardDetailCards.length}`;
      cardDetailCounter.style.display = cardDetailCards.length > 1 ? 'block' : 'none';

      // Show play button only if viewing hand and it's player's turn to play (not for ages)
      const canPlay = !isAge &&
                      cardDetailSource === 'hand' &&
                      gameState &&
                      gameState.isMyTurn &&
                      gameState.turnPhase === 'play' &&
                      !gameState.pendingAction;
      cardDetailPlay.style.display = canPlay ? 'inline-block' : 'none';
      cardDetailPlayable = canPlay;
    }

    // Navigate to previous card
    function showPrevCard() {
      if (cardDetailCards.length <= 1) return;
      cardDetailIndex = (cardDetailIndex - 1 + cardDetailCards.length) % cardDetailCards.length;
      renderCardDetail();
    }

    // Navigate to next card
    function showNextCard() {
      if (cardDetailCards.length <= 1) return;
      cardDetailIndex = (cardDetailIndex + 1) % cardDetailCards.length;
      renderCardDetail();
    }

    // Play card from detail view
    function playFromDetail() {
      if (!cardDetailPlayable || cardDetailSource !== 'hand') return;
      const cardIndex = cardDetailIndex;
      cardDetailOverlay.style.display = 'none';
      playCard(cardIndex);
    }

    // Show age history in card detail view
    function showAgeHistory() {
      if (ageHistory.length === 0) return;

      // Find current age index in history
      const currentIndex = gameState.currentAge
        ? ageHistory.findIndex(age => age.name === gameState.currentAge.name)
        : ageHistory.length - 1;

      showCardDetail(
        ageHistory[currentIndex >= 0 ? currentIndex : ageHistory.length - 1],
        ageHistory,
        currentIndex >= 0 ? currentIndex : ageHistory.length - 1,
        'ages'
      );
    }

    // Event listeners for card detail
    cardDetailClose.addEventListener('click', () => {
      cardDetailOverlay.style.display = 'none';
    });

    cardDetailOverlay.querySelector('.card-detail-backdrop').addEventListener('click', () => {
      cardDetailOverlay.style.display = 'none';
    });

    cardDetailPrev.addEventListener('click', (e) => {
      e.stopPropagation();
      showPrevCard();
    });

    cardDetailNext.addEventListener('click', (e) => {
      e.stopPropagation();
      showNextCard();
    });

    cardDetailPlay.addEventListener('click', (e) => {
      e.stopPropagation();
      playFromDetail();
    });

    // Keyboard navigation for card detail
    document.addEventListener('keydown', (e) => {
      if (cardDetailOverlay.style.display !== 'flex') return;
      if (e.key === 'ArrowLeft') showPrevCard();
      else if (e.key === 'ArrowRight') showNextCard();
      else if (e.key === 'Escape') cardDetailOverlay.style.display = 'none';
    });

    // Make age card clickable to show history
    ageCard.addEventListener('click', () => {
      showAgeHistory();
    });

    // Add cursor pointer style to age card
    ageCard.style.cursor = 'pointer';

    // Render action log
    function renderLog() {
      actionLog.innerHTML = '';
      (gameState.actionLog || []).slice().reverse().forEach(entry => {
        const div = document.createElement('div');
        div.className = 'log-entry';
        div.textContent = entry.message;
        actionLog.appendChild(div);
      });
    }

    // Play a card
    function playCard(cardIndex) {
      if (!gameState.isMyTurn || gameState.turnPhase !== 'play') return;
      const result = peerManager.playCard(cardIndex);
      if (!result.success && result.error) {
        alert(result.error);
      }
    }

    // Handle pending action
    function handlePendingAction(action) {
      pendingAction = action;

      switch (action.inputType) {
        case 'view_cards':
          showViewCardsModal(action);
          break;
        case 'select_opponent':
          showSelectOpponentModal(action);
          break;
        case 'select_opponent_trait':
          showSelectOpponentTraitModal(action);
          break;
        case 'select_own_cards':
          showSelectOwnCardsModal(action);
          break;
        case 'select_own_trait':
          showSelectOwnTraitModal(action);
          break;
        case 'select_from_discard':
          showSelectFromDiscardModal(action);
          break;
      }
    }

    // Modal helpers
    function showModal(title, content, showConfirm = false, showSkip = false) {
      modalTitle.textContent = title;
      modalCards.innerHTML = content;
      modalConfirm.style.display = showConfirm ? 'block' : 'none';
      modalSkip.style.display = showSkip ? 'block' : 'none';
      modal.style.display = 'flex';
    }

    function hideModal() {
      modal.style.display = 'none';
      selectedCards = [];
      pendingAction = null;
    }

    modalClose.addEventListener('click', hideModal);

    modalSkip.addEventListener('click', () => {
      peerManager.skipAction();
      hideModal();
    });

    function showViewCardsModal(action) {
      const cardsHtml = action.cards.map(card => {
        if (card.type) {
          return `<div class="card colorless">
            <div class="card-name">${card.name}</div>
            <div class="card-effect">${card.effect || ''}</div>
          </div>`;
        }
        return createCardElement(card, false).outerHTML;
      }).join('');
      showModal(action.message || 'Cards', cardsHtml, false, true);
    }

    function showSelectOpponentModal(action) {
      const content = action.options.map(opp => `
        <button class="secondary" style="padding: 20px 30px; margin: 5px;"
                onclick="window.selectOpponent('${opp.id}')">
          ${opp.name}${opp.handSize !== undefined ? ` (${opp.handSize} cards)` : ''}
        </button>
      `).join('');
      showModal(action.message || 'Select Opponent', content, false, action.optional);
    }

    window.selectOpponent = function(targetId) {
      const result = peerManager.selectTarget({ targetId, effectType: pendingAction.effectType });
      if (result.viewHand) {
        const cardsHtml = result.viewHand.map(c => createCardElement(c, false).outerHTML).join('');
        showModal(result.message || "Opponent's Hand", cardsHtml, false, true);
      } else {
        hideModal();
      }
    };

    function showSelectOpponentTraitModal(action) {
      let content = '';
      action.options.forEach(opp => {
        content += `<div style="margin-bottom: 20px;">
          <h4 style="margin-bottom: 10px;">${opp.name}</h4>
          <div style="display: flex; flex-wrap: wrap; gap: 10px;">
            ${opp.traits.map(t => `
              <div class="card ${getColorClass(t.color)}" style="cursor: pointer;"
                   onclick="window.selectOpponentTrait('${opp.id}', ${t.index})">
                <div class="card-face">${formatFace(t.faceValue)}</div>
                <div class="card-name">${t.name}</div>
              </div>
            `).join('')}
          </div>
        </div>`;
      });
      showModal(action.message || 'Select Trait', content, false, action.optional);
    }

    window.selectOpponentTrait = function(targetId, traitIndex) {
      peerManager.selectTarget({ targetId, traitIndex, effectType: pendingAction.effectType });
      hideModal();
    };

    function showSelectOwnCardsModal(action) {
      selectedCards = [];
      const count = action.count || 1;
      const cardsHtml = action.options.map((c, i) => `
        <div class="card ${getColorClass(c.color)}" data-index="${c.index}"
             style="cursor: pointer;" onclick="window.toggleCardSelection(${c.index}, ${count})">
          <div class="card-face">${formatFace(c.faceValue)}</div>
          <div class="card-name">${c.name}</div>
        </div>
      `).join('');
      showModal(`Select ${count} card(s)`, cardsHtml, true, action.optional);

      modalConfirm.onclick = () => {
        if (selectedCards.length === 0) {
          alert('Select at least one card');
          return;
        }
        peerManager.selectCards({ indices: selectedCards, effectType: pendingAction.effectType });
        hideModal();
      };
    }

    window.toggleCardSelection = function(index, maxCount) {
      const card = modalCards.querySelector(`[data-index="${index}"]`);
      const idx = selectedCards.indexOf(index);
      if (idx === -1) {
        if (selectedCards.length < maxCount) {
          selectedCards.push(index);
          card.classList.add('selected');
        }
      } else {
        selectedCards.splice(idx, 1);
        card.classList.remove('selected');
      }
    };

    function showSelectOwnTraitModal(action) {
      const cardsHtml = action.options.map(t => `
        <div class="card ${getColorClass(t.color)}" style="cursor: pointer;"
             onclick="window.selectOwnTrait(${t.index})">
          <div class="card-face">${formatFace(t.faceValue)}</div>
          <div class="card-name">${t.name}</div>
        </div>
      `).join('');
      showModal(action.message || 'Select Trait', cardsHtml, false, action.optional);
    }

    window.selectOwnTrait = function(index) {
      peerManager.selectCards({ index, effectType: pendingAction.effectType });
      hideModal();
    };

    function showSelectFromDiscardModal(action) {
      const cardsHtml = action.options.map(c => `
        <div class="card ${getColorClass(c.color)}" style="cursor: pointer;"
             onclick="window.selectFromDiscard(${c.index})">
          <div class="card-face">${formatFace(c.faceValue)}</div>
          <div class="card-name">${c.name}</div>
        </div>
      `).join('');
      showModal('Select from Discard', cardsHtml, false, action.optional);
    }

    window.selectFromDiscard = function(index) {
      peerManager.selectCards({ index, effectType: pendingAction.effectType });
      hideModal();
    };

    // Show game over
    function showGameOver() {
      const sorted = [...gameState.players].sort((a, b) => b.score - a.score);
      finalScores.innerHTML = sorted.map((p, i) => `
        <div class="score-row${i === 0 ? ' winner' : ''}">
          <span class="rank">#${i + 1}</span>
          <span class="name">${p.name}${p.id === playerData.playerId ? ' (You)' : ''}</span>
          <span class="score">${p.score} pts</span>
        </div>
      `).join('');
      reconnectManager.clearSession(); // Clear session when game ends
      gameOverOverlay.style.display = 'flex';
    }

    // Hand view toggle
    handViewToggle.onclick = () => {
      handViewMode = handViewMode === 'text' ? 'image' : 'text';
      handViewToggle.querySelector('.toggle-icon').textContent = handViewMode === 'image' ? 'üìù' : 'üñºÔ∏è';
      renderHand();
    };
  </script>
</body>
</html>
