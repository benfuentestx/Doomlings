<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Doomlings - Game</title>
  <link rel="stylesheet" href="/css/styles.css">
</head>
<body>
  <div class="game-container" id="game-container">
    <!-- Game Header -->
    <div class="game-header">
      <div class="age-display">
        <div class="age-card" id="age-card">
          <div class="age-name">Loading...</div>
          <div class="age-effect"></div>
        </div>
        <div class="catastrophe-counter">
          <div class="catastrophe-dot" id="cat-1"></div>
          <div class="catastrophe-dot" id="cat-2"></div>
          <div class="catastrophe-dot" id="cat-3"></div>
        </div>
      </div>
      <div id="turn-indicator"></div>
      <div class="game-stats">
        <span>Round: <strong id="round-num">1</strong></span>
        <span>Deck: <strong id="deck-size">0</strong></span>
        <span>Discard: <strong id="discard-size">0</strong></span>
      </div>
    </div>

    <!-- Left Panel - Opponents -->
    <div class="opponents-panel" id="opponents-left"></div>

    <!-- Main Play Area -->
    <div class="play-area">
      <!-- Action Area -->
      <div class="action-area" id="action-area">
        <div class="action-message" id="action-message">Waiting for game to start...</div>
        <div class="action-options" id="action-options"></div>
      </div>

      <!-- My Trait Pile -->
      <div class="my-traits">
        <h3>
          <span>Your Trait Pile</span>
          <span class="my-score" id="my-score">0 pts</span>
        </h3>
        <div class="trait-pile" id="my-trait-pile"></div>
      </div>

      <!-- Action Log -->
      <div class="log-panel">
        <h4>Game Log</h4>
        <div id="action-log"></div>
      </div>
    </div>

    <!-- Right Panel - More Opponents -->
    <div class="opponents-panel" id="opponents-right"></div>

    <!-- My Hand -->
    <div class="my-hand-area">
      <div class="hand-header">
        <h3>Your Hand (<span id="hand-count">0</span> cards)</h3>
        <span id="play-instruction"></span>
      </div>
      <div class="my-hand" id="my-hand"></div>
    </div>
  </div>

  <!-- Modal for card selection -->
  <div class="modal-overlay" id="modal" style="display: none;">
    <div class="modal-content">
      <h2 id="modal-title">Select</h2>
      <div class="modal-cards" id="modal-cards"></div>
      <div class="modal-actions" id="modal-actions">
        <button id="modal-confirm" style="display: none;">Confirm</button>
        <button id="modal-skip" class="secondary" style="display: none;">Skip</button>
        <button id="modal-close" class="secondary">Close</button>
      </div>
    </div>
  </div>

  <!-- Game Over Overlay -->
  <div class="game-over-overlay" id="game-over" style="display: none;">
    <div class="game-over-content">
      <h1>Game Over!</h1>
      <div class="final-scores" id="final-scores"></div>
      <button onclick="location.href='/'">Back to Home</button>
    </div>
  </div>

  <!-- Loading -->
  <div id="loading" class="message-overlay">
    <div class="spinner"></div>
    <p>Loading game...</p>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();

    // Get player data
    let playerData = JSON.parse(sessionStorage.getItem('playerData'));
    let gameState = null;
    let selectedCards = [];
    let pendingAction = null;

    // DOM Elements
    const loadingOverlay = document.getElementById('loading');
    const gameContainer = document.getElementById('game-container');
    const ageCard = document.getElementById('age-card');
    const turnIndicator = document.getElementById('turn-indicator');
    const roundNum = document.getElementById('round-num');
    const deckSize = document.getElementById('deck-size');
    const discardSize = document.getElementById('discard-size');
    const actionMessage = document.getElementById('action-message');
    const actionOptions = document.getElementById('action-options');
    const myTraitPile = document.getElementById('my-trait-pile');
    const myHand = document.getElementById('my-hand');
    const myScore = document.getElementById('my-score');
    const handCount = document.getElementById('hand-count');
    const playInstruction = document.getElementById('play-instruction');
    const actionLog = document.getElementById('action-log');
    const opponentsLeft = document.getElementById('opponents-left');
    const opponentsRight = document.getElementById('opponents-right');
    const modal = document.getElementById('modal');
    const modalTitle = document.getElementById('modal-title');
    const modalCards = document.getElementById('modal-cards');
    const modalConfirm = document.getElementById('modal-confirm');
    const modalSkip = document.getElementById('modal-skip');
    const modalClose = document.getElementById('modal-close');
    const gameOverOverlay = document.getElementById('game-over');
    const finalScores = document.getElementById('final-scores');

    // Check session
    if (!playerData) {
      window.location.href = '/';
    } else {
      // Reconnect to game
      socket.emit('joinGame', {
        gameId: playerData.gameId,
        playerName: playerData.playerName
      }, (response) => {
        if (!response.success) {
          alert('Failed to reconnect');
          window.location.href = '/';
        }
      });
    }

    // Listen for game state updates
    socket.on('gameState', (state) => {
      loadingOverlay.style.display = 'none';
      gameState = state;
      renderGame();
    });

    // Render the game
    function renderGame() {
      if (!gameState) return;

      // Update catastrophe dots
      for (let i = 1; i <= 3; i++) {
        const dot = document.getElementById(`cat-${i}`);
        dot.classList.toggle('active', i <= gameState.catastropheCount);
      }

      // Update age card
      if (gameState.currentAge) {
        const isCatastrophe = gameState.currentAge.type === 'catastrophe';
        ageCard.className = 'age-card' + (isCatastrophe ? ' catastrophe' : '');
        ageCard.innerHTML = `
          <div class="age-name">${gameState.currentAge.name}</div>
          <div class="age-effect">${gameState.currentAge.effect || ''}</div>
        `;
      }

      // Update stats
      roundNum.textContent = gameState.round;
      deckSize.textContent = gameState.deckSize;
      discardSize.textContent = gameState.discardSize;

      // Update turn indicator
      if (gameState.state === 'finished') {
        turnIndicator.innerHTML = '<span class="turn-indicator" style="background: var(--success);">Game Over</span>';
      } else if (gameState.isMyTurn) {
        turnIndicator.innerHTML = '<span class="turn-indicator">Your Turn!</span>';
      } else {
        const currentPlayer = gameState.players.find(p => p.isCurrentPlayer);
        turnIndicator.innerHTML = `<span style="color: var(--text-secondary);">${currentPlayer?.name || 'Unknown'}'s turn</span>`;
      }

      // Update my score
      myScore.textContent = `${gameState.myScore} pts`;

      // Render my trait pile
      renderTraitPile(myTraitPile, gameState.myTraitPile);

      // Render my hand
      renderHand();

      // Render opponents
      renderOpponents();

      // Update action area
      updateActionArea();

      // Update log
      renderLog();

      // Check for game over
      if (gameState.state === 'finished') {
        showGameOver();
      }

      // Handle pending action
      if (gameState.pendingAction) {
        handlePendingAction(gameState.pendingAction);
      }
    }

    // Render a trait pile
    function renderTraitPile(container, cards) {
      container.innerHTML = '';
      cards.forEach((card, index) => {
        container.appendChild(createCardElement(card, false, index));
      });
    }

    // Render hand
    function renderHand() {
      myHand.innerHTML = '';
      handCount.textContent = gameState.myHand.length;

      const canPlay = gameState.isMyTurn && gameState.turnPhase === 'play' && !gameState.pendingAction;

      gameState.myHand.forEach((card, index) => {
        const cardEl = createCardElement(card, canPlay, index);
        if (canPlay) {
          cardEl.addEventListener('click', () => playCard(index));
        }
        myHand.appendChild(cardEl);
      });

      playInstruction.textContent = canPlay ? 'Click a card to play it' : '';
    }

    // Create a card element
    function createCardElement(card, playable = false, index = 0) {
      const div = document.createElement('div');
      const colorClass = getColorClass(card.color);
      div.className = `card ${colorClass}${playable ? ' playable' : ''}`;
      div.dataset.index = index;

      // Get card type text
      let typeText = '';
      if (card.dominant) typeText = 'DOMINANT';
      else if (card.action) typeText = 'ACTION';
      else if (card.drops) typeText = 'DROP';
      else if (card.gene_pool) typeText = 'GENE POOL';
      else if (card.worlds_end) typeText = "WORLD'S END";
      else if (card.effectless) typeText = 'TRAIT';

      // Get effect description
      let effectText = getCardEffectText(card);

      div.innerHTML = `
        <div class="card-color" style="background: ${getColorValue(card.color)}"></div>
        <div class="card-face">${formatFace(card.face)}</div>
        <div class="card-name">${card.trait}</div>
        <div class="card-effect">${effectText}</div>
        <div class="card-type">${typeText}</div>
      `;

      return div;
    }

    // Get color class
    function getColorClass(color) {
      if (!color) return 'colorless';
      if (color.includes('_')) return 'multi';
      return color.toLowerCase();
    }

    // Get color CSS value
    function getColorValue(color) {
      const colors = {
        'Red': '#e74c3c',
        'Blue': '#3498db',
        'Green': '#27ae60',
        'Purple': '#9b59b6',
        'Colorless': '#95a5a6'
      };
      if (color && color.includes('_')) {
        return 'linear-gradient(135deg, #e74c3c, #3498db, #27ae60, #9b59b6)';
      }
      return colors[color] || colors['Colorless'];
    }

    // Format face value
    function formatFace(face) {
      if (face === 'variable') return '?';
      if (face === 'copy_1st_dominant') return '=';
      return face;
    }

    // Get card effect text
    function getCardEffectText(card) {
      if (card.effectless) return '';
      if (card.drop_effect) {
        return formatDropEffect(card.drop_effect);
      }
      if (card.action) return 'Action effect';
      if (card.dominant) return 'Dominant';
      return '';
    }

    // Format drop effect for display
    function formatDropEffect(effect) {
      if (!effect) return '';
      const parts = effect.split(' ');
      if (parts.length < 3) return effect;

      const value = parts[0];
      const condition = parts[2] || '';

      const conditionMap = {
        'n_hand': 'per card in hand',
        'n_traits': 'per trait',
        'n_blue': 'per Blue trait',
        'n_green': 'per Green trait',
        'n_purple': 'per Purple trait',
        'n_colorless': 'per Colorless trait',
        'n_negative': 'per negative trait',
        'n_colors': 'per unique color',
        'n_color_pairs': 'per color pair',
        'if_most_traits': 'if most traits'
      };

      const text = conditionMap[condition] || condition.replace(/_/g, ' ');
      if (value === 'n') return `Variable: ${text}`;
      return `${value > 0 ? '+' : ''}${value} ${text}`;
    }

    // Render opponents
    function renderOpponents() {
      const opponents = gameState.players.filter(p => p.id !== playerData.playerId);
      opponentsLeft.innerHTML = '';
      opponentsRight.innerHTML = '';

      opponents.forEach((opp, i) => {
        const container = i % 2 === 0 ? opponentsLeft : opponentsRight;
        const div = document.createElement('div');
        div.className = `opponent-card${opp.isCurrentPlayer ? ' current-turn' : ''}`;

        div.innerHTML = `
          <div class="opponent-header">
            <span class="opponent-name">${opp.name}</span>
            <span class="opponent-score">${opp.score}</span>
          </div>
          <div class="opponent-info">
            Hand: ${opp.handSize} | Traits: ${opp.traitPile.length}
            ${opp.hasPlayedThisRound ? ' | Played' : ''}
          </div>
          <div class="opponent-traits">
            ${opp.traitPile.map(t => `
              <div class="mini-trait ${getColorClass(t.color)}" title="${t.trait} (${t.face})">
                ${formatFace(t.face)}
              </div>
            `).join('')}
          </div>
        `;

        container.appendChild(div);
      });
    }

    // Update action area
    function updateActionArea() {
      actionOptions.innerHTML = '';

      if (gameState.state === 'finished') {
        actionMessage.textContent = 'Game Over!';
        return;
      }

      if (gameState.pendingAction) {
        actionMessage.textContent = gameState.pendingAction.message || 'Action required';
        return;
      }

      if (gameState.isMyTurn) {
        if (gameState.turnPhase === 'play') {
          actionMessage.textContent = 'Play a trait from your hand';
        } else {
          actionMessage.textContent = 'Waiting for next phase...';
        }
      } else {
        const currentPlayer = gameState.players.find(p => p.isCurrentPlayer);
        actionMessage.textContent = `Waiting for ${currentPlayer?.name || 'opponent'}...`;
      }
    }

    // Render action log
    function renderLog() {
      actionLog.innerHTML = '';
      const logs = gameState.actionLog || [];
      logs.slice().reverse().forEach(entry => {
        const div = document.createElement('div');
        div.className = 'log-entry';
        div.textContent = entry.message;
        actionLog.appendChild(div);
      });
    }

    // Play a card
    function playCard(cardIndex) {
      if (!gameState.isMyTurn || gameState.turnPhase !== 'play') return;

      socket.emit('playCard', { cardIndex }, (response) => {
        if (!response.success) {
          alert(response.error || 'Failed to play card');
        }
      });
    }

    // Handle pending action that needs input
    function handlePendingAction(action) {
      pendingAction = action;

      switch (action.inputType) {
        case 'view_cards':
          showViewCardsModal(action);
          break;

        case 'select_opponent':
          showSelectOpponentModal(action);
          break;

        case 'select_opponent_trait':
          showSelectOpponentTraitModal(action);
          break;

        case 'select_own_cards':
          showSelectOwnCardsModal(action);
          break;

        case 'select_own_trait':
          showSelectOwnTraitModal(action);
          break;

        case 'select_from_discard':
          showSelectFromDiscardModal(action);
          break;

        case 'select_player_and_cards':
          showSelectPlayerAndCardsModal(action);
          break;

        case 'select_trait_swap':
          showTraitSwapModal(action);
          break;

        default:
          console.log('Unknown action type:', action.inputType);
      }
    }

    // Modal helpers
    function showModal(title, content, showConfirm = false, showSkip = false) {
      modalTitle.textContent = title;
      modalCards.innerHTML = content;
      modalConfirm.style.display = showConfirm ? 'block' : 'none';
      modalSkip.style.display = showSkip ? 'block' : 'none';
      modal.style.display = 'flex';
    }

    function hideModal() {
      modal.style.display = 'none';
      selectedCards = [];
      pendingAction = null;
    }

    modalClose.addEventListener('click', hideModal);

    modalSkip.addEventListener('click', () => {
      socket.emit('skipAction', (response) => {
        hideModal();
        if (!response.success) {
          alert(response.error || 'Cannot skip this action');
        }
      });
    });

    // View cards modal (just for viewing, no action)
    function showViewCardsModal(action) {
      const cardsHtml = action.cards.map(card => {
        if (card.type) {
          // Age card
          return `<div class="card colorless">
            <div class="card-name">${card.name}</div>
            <div class="card-effect">${card.effect || ''}</div>
            <div class="card-type">${card.type.toUpperCase()}</div>
          </div>`;
        } else {
          // Trait card
          return createCardElement(card, false).outerHTML;
        }
      }).join('');

      showModal(action.message || 'Cards', cardsHtml, false, true);
    }

    // Select opponent modal
    function showSelectOpponentModal(action) {
      const content = action.options.map(opp => `
        <button class="secondary" style="padding: 20px 30px; margin: 5px;"
                onclick="selectOpponent('${opp.id}')">
          ${opp.name}${opp.handSize !== undefined ? ` (${opp.handSize} cards)` : ''}
        </button>
      `).join('');

      showModal(action.message || 'Select Opponent', content, false, action.optional);
    }

    window.selectOpponent = function(targetId) {
      socket.emit('selectTarget', {
        targetId,
        effectType: pendingAction.effectType
      }, (response) => {
        if (response.success) {
          if (response.viewHand) {
            // Show opponent's hand
            const cardsHtml = response.viewHand.map(c => createCardElement(c, false).outerHTML).join('');
            showModal(response.message || "Opponent's Hand", cardsHtml, false, true);
          } else {
            hideModal();
          }
        } else {
          alert(response.error || 'Action failed');
        }
      });
    };

    // Select opponent trait modal
    function showSelectOpponentTraitModal(action) {
      let content = '';
      action.options.forEach(opp => {
        content += `<div style="margin-bottom: 20px;">
          <h4 style="margin-bottom: 10px;">${opp.name}</h4>
          <div style="display: flex; flex-wrap: wrap; gap: 10px;">
            ${opp.traits.map(t => `
              <div class="card ${getColorClass(t.color)}" style="cursor: pointer;"
                   onclick="selectOpponentTrait('${opp.id}', ${t.index})">
                <div class="card-face">${formatFace(t.face)}</div>
                <div class="card-name">${t.trait}</div>
              </div>
            `).join('')}
          </div>
        </div>`;
      });

      showModal(action.message || 'Select Trait', content, false, action.optional);
    }

    window.selectOpponentTrait = function(targetId, traitIndex) {
      socket.emit('selectTarget', {
        targetId,
        traitIndex,
        effectType: pendingAction.effectType
      }, (response) => {
        hideModal();
        if (!response.success) {
          alert(response.error || 'Action failed');
        }
      });
    };

    // Select own cards modal
    function showSelectOwnCardsModal(action) {
      selectedCards = [];
      const count = action.count || 1;

      const cardsHtml = action.options.map((c, i) => `
        <div class="card ${getColorClass(c.color)}" data-index="${c.index}"
             style="cursor: pointer;" onclick="toggleCardSelection(${c.index}, ${count})">
          <div class="card-face">${formatFace(c.face)}</div>
          <div class="card-name">${c.trait}</div>
        </div>
      `).join('');

      showModal(`Select ${count} card(s)`, cardsHtml, true, action.optional);

      modalConfirm.onclick = () => {
        if (selectedCards.length === 0) {
          alert('Please select at least one card');
          return;
        }
        socket.emit('selectCards', {
          indices: selectedCards,
          effectType: pendingAction.effectType
        }, (response) => {
          hideModal();
          if (!response.success) {
            alert(response.error || 'Action failed');
          }
        });
      };
    }

    window.toggleCardSelection = function(index, maxCount) {
      const card = modalCards.querySelector(`[data-index="${index}"]`);
      const idx = selectedCards.indexOf(index);

      if (idx === -1) {
        if (selectedCards.length < maxCount) {
          selectedCards.push(index);
          card.classList.add('selected');
        }
      } else {
        selectedCards.splice(idx, 1);
        card.classList.remove('selected');
      }
    };

    // Select own trait modal
    function showSelectOwnTraitModal(action) {
      const cardsHtml = action.options.map(t => `
        <div class="card ${getColorClass(t.color)}" style="cursor: pointer;"
             onclick="selectOwnTrait(${t.index})">
          <div class="card-face">${formatFace(t.face)}</div>
          <div class="card-name">${t.trait}</div>
        </div>
      `).join('');

      showModal(action.message || 'Select Trait', cardsHtml, false, action.optional);
    }

    window.selectOwnTrait = function(index) {
      socket.emit('selectCards', {
        index,
        effectType: pendingAction.effectType
      }, (response) => {
        hideModal();
        if (!response.success) {
          alert(response.error || 'Action failed');
        }
      });
    };

    // Select from discard modal
    function showSelectFromDiscardModal(action) {
      const cardsHtml = action.options.map(c => `
        <div class="card ${getColorClass(c.color)}" style="cursor: pointer;"
             onclick="selectFromDiscard(${c.index})">
          <div class="card-face">${formatFace(c.face)}</div>
          <div class="card-name">${c.trait}</div>
        </div>
      `).join('');

      showModal('Select from Discard Pile', cardsHtml, false, action.optional);
    }

    window.selectFromDiscard = function(index) {
      socket.emit('selectCards', {
        index,
        effectType: pendingAction.effectType
      }, (response) => {
        hideModal();
        if (!response.success) {
          alert(response.error || 'Action failed');
        }
      });
    };

    // Select player and cards modal
    function showSelectPlayerAndCardsModal(action) {
      selectedCards = [];
      let selectedPlayer = null;

      const content = `
        <div style="margin-bottom: 20px;">
          <h4>Select Player:</h4>
          <div id="player-buttons">
            ${action.players.map(p => `
              <button class="secondary player-btn" data-player="${p.id}"
                      onclick="selectGivePlayer('${p.id}')">${p.name}</button>
            `).join('')}
          </div>
        </div>
        <div>
          <h4>Select Cards to Give:</h4>
          <div style="display: flex; flex-wrap: wrap; gap: 10px;">
            ${action.cards.map(c => `
              <div class="card ${getColorClass(c.color)}" data-index="${c.index}"
                   style="cursor: pointer;" onclick="toggleCardSelection(${c.index}, ${action.count})">
                <div class="card-face">${formatFace(c.face)}</div>
                <div class="card-name">${c.trait}</div>
              </div>
            `).join('')}
          </div>
        </div>
      `;

      showModal(action.message || 'Give Cards', content, true, action.optional);

      window.selectGivePlayer = function(playerId) {
        selectedPlayer = playerId;
        document.querySelectorAll('.player-btn').forEach(btn => {
          btn.classList.toggle('selected', btn.dataset.player === playerId);
        });
      };

      modalConfirm.onclick = () => {
        if (!selectedPlayer) {
          alert('Please select a player');
          return;
        }
        if (selectedCards.length === 0) {
          alert('Please select card(s) to give');
          return;
        }
        socket.emit('selectCards', {
          targetId: selectedPlayer,
          indices: selectedCards,
          effectType: pendingAction.effectType
        }, (response) => {
          hideModal();
          if (!response.success) {
            alert(response.error || 'Action failed');
          }
        });
      };
    }

    // Trait swap modal
    function showTraitSwapModal(action) {
      let selectedOwnTrait = null;
      let selectedOppId = null;
      let selectedOppTrait = null;

      let content = `
        <div style="margin-bottom: 20px;">
          <h4>Your Trait to Swap:</h4>
          <div style="display: flex; flex-wrap: wrap; gap: 10px;">
            ${action.ownTraits.map(t => `
              <div class="card ${getColorClass(t.color)} own-trait" data-index="${t.index}"
                   style="cursor: pointer;" onclick="selectSwapOwnTrait(${t.index})">
                <div class="card-face">${formatFace(t.face)}</div>
                <div class="card-name">${t.trait}</div>
              </div>
            `).join('')}
          </div>
        </div>
      `;

      action.opponents.forEach(opp => {
        content += `
          <div style="margin-bottom: 20px;">
            <h4>${opp.name}'s Traits:</h4>
            <div style="display: flex; flex-wrap: wrap; gap: 10px;">
              ${opp.traits.map(t => `
                <div class="card ${getColorClass(t.color)} opp-trait"
                     data-player="${opp.id}" data-index="${t.index}"
                     style="cursor: pointer;" onclick="selectSwapOppTrait('${opp.id}', ${t.index})">
                  <div class="card-face">${formatFace(t.face)}</div>
                  <div class="card-name">${t.trait}</div>
                </div>
              `).join('')}
            </div>
          </div>
        `;
      });

      showModal('Swap Traits', content, true, action.optional);

      window.selectSwapOwnTrait = function(index) {
        selectedOwnTrait = index;
        document.querySelectorAll('.own-trait').forEach(el => {
          el.classList.toggle('selected', parseInt(el.dataset.index) === index);
        });
      };

      window.selectSwapOppTrait = function(playerId, index) {
        selectedOppId = playerId;
        selectedOppTrait = index;
        document.querySelectorAll('.opp-trait').forEach(el => {
          el.classList.toggle('selected',
            el.dataset.player === playerId && parseInt(el.dataset.index) === index);
        });
      };

      modalConfirm.onclick = () => {
        if (selectedOwnTrait === null || selectedOppId === null || selectedOppTrait === null) {
          alert('Please select both traits to swap');
          return;
        }
        socket.emit('selectCards', {
          ownTraitIndex: selectedOwnTrait,
          opponentId: selectedOppId,
          opponentTraitIndex: selectedOppTrait,
          effectType: pendingAction.effectType
        }, (response) => {
          hideModal();
          if (!response.success) {
            alert(response.error || 'Action failed');
          }
        });
      };
    }

    // Show game over
    function showGameOver() {
      const sorted = [...gameState.players].sort((a, b) => b.score - a.score);

      finalScores.innerHTML = sorted.map((p, i) => `
        <div class="score-row${i === 0 ? ' winner' : ''}">
          <span class="rank">#${i + 1}</span>
          <span class="name">${p.name}${p.id === playerData.playerId ? ' (You)' : ''}</span>
          <span class="score">${p.score} pts</span>
        </div>
      `).join('');

      gameOverOverlay.style.display = 'flex';
    }

    // Handle reconnection
    socket.on('disconnect', () => {
      loadingOverlay.querySelector('p').textContent = 'Reconnecting...';
      loadingOverlay.style.display = 'block';
    });

    socket.on('connect', () => {
      if (playerData) {
        socket.emit('joinGame', {
          gameId: playerData.gameId,
          playerName: playerData.playerName
        }, () => {});
      }
    });
  </script>
</body>
</html>
